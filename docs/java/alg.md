# 数据结构与算法
## HashMap
### HashCode为什么使用31作为乘数
![avatar](/interview-3-01.png)
1. 31 是一个奇质数，如果选择偶数会导致乘积运算时数据溢出。

2. 另外在二进制中，2个5次方是32，那么也就是 31 * i == (i << 5) - i。这主要是说乘积运算可以使用位移提升性能，同时目前的JVM虚拟机也会自动支持此类的优化。
![avatar](/interview-3-03.png)
以上就是不同的乘数下的hash碰撞结果图标展示，从这里可以看出如下信息；

乘数是2时，hash的取值范围比较小，基本是堆积到一个范围内了，后面内容会看到这块的展示。
乘数是3、5、7、17等，都有较大的碰撞概率
乘数是31的时候，碰撞的概率已经很小了，基本稳定。
顺着往下看，你会发现199的碰撞概率更小，这就相当于一排奇数的茅坑量多，自然会减少碰撞。但这个范围值已经远超过int的取值范围了，如果用此数作为乘数，又返回int值，就会丢失数据信息。

![avatar](/interview-3-04.png)

#### 总结：
以上主要介绍了hashCode选择31作为乘数的主要原因和实验数据验证，算是一个散列的数据结构的案例讲解，在后续的类似技术中，就可以解释其他的源码设计思路了。
看过本文至少应该让你可以从根本上解释了hashCode的设计，关于他的所有问题也就不需要死记硬背了，学习编程内容除了最开始的模仿到深入以后就需要不断的研究数学逻辑和数据结构。
具体实验过程请看<http://s.xiaoyuan.space/3ieI5j>

### HashMap核心知识，扰动函数、负载因子、扩容链表拆分，深度学习